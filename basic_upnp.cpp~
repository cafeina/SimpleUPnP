#include <arpa/inet.h>
#include <ifaddrs.h>
#include <iostream>
#include <netinet/in.h>
#include <sstream>
#include <stdexcept>
#include <string.h>
#include <sys/fcntl.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include "basic_upnp.h"
#include "../utilities/utilities.h"

using namespace std;
using namespace tinyxml2;

SimpleUPnP::SimpleUPnP(int time_out_) : time_out(time_out_)
{
	get_igd_location();
}
SimpleUPnP::~SimpleUPnP() { close(tcp_sock); }

void SimpleUPnP::get_igd_location()
{
	/*** Sends a broadcast to discover the Internet Gateway Device Location ***/
	send_broadcast();

    for(int i = 0; i < time_out; ++i) {
    	sleep(1);
        string upnp_response = read_response(udp_broadcast_socket, "Discovery");

        if(!upnp_response.empty()) {
            parse_igd_location(upnp_response);
            get_description();
            break;
        }
    }

    close(udp_broadcast_socket);
}

void SimpleUPnP::parse_igd_location(string &upnp_response)
{
    string::size_type begin = upnp_response.find("http://");
    string::size_type end = upnp_response.find("\r", begin);
    string location_url = upnp_response.assign(upnp_response, begin, end-begin);

    string::size_type host_begin, port_begin, path_begin;
    host_begin = location_url.find("://") + 3;
    port_begin = location_url.find(":", host_begin) + 1;
    path_begin = location_url.find("/", port_begin) + 1;

    igd_host = location_url.substr(host_begin, port_begin-host_begin-1);
    string str_port = location_url.substr(port_begin, path_begin-port_begin-1);
    igd_port = stoi(str_port);
    igd_path = location_url.substr(path_begin-1);
}

std::string SimpleUPnP::AddPortMapping(unsigned short new_external_port, const string &new_protocol, unsigned short new_internal_port,
						const string &new_internal_client, const string &new_port_mapping_description, int new_lease_duration)
{
	string control_parameters = "<NewRemoteHost></NewRemoteHost>\r\n"                           \
								"<NewExternalPort>%u</NewExternalPort>\r\n"                     \
								"<NewProtocol>%s</NewProtocol>\r\n"                             \
								"<NewInternalPort>%u</NewInternalPort>\r\n"                     \
								"<NewInternalClient>%s</NewInternalClient>\r\n"                 \
								"<NewEnabled>1</NewEnabled>\r\n"                                \
								"<NewPortMappingDescription>%s</NewPortMappingDescription>\r\n" \
								"<NewLeaseDuration>%d</NewLeaseDuration>";

	string command = "AddPortMapping";
	string command_arguments = format_string(control_parameters, new_external_port, new_protocol.c_str(), new_internal_port,
										new_internal_client.c_str(), new_port_mapping_description.c_str(), new_lease_duration);

	string request = make_request(command, command_arguments);
	return exec_command(command, request);

}

void SimpleUPnP::DeletePortMapping(unsigned short new_external_port, const string &new_protocol)
{
	string control_parameters = "<NewRemoteHost></NewRemoteHost>\r\n"       \
								"<NewExternalPort>%u</NewExternalPort>\r\n" \
								"<NewProtocol>%s</NewProtocol>";

	const string command = "DeletePortMapping";
	string command_arguments = format_string(control_parameters, new_external_port, new_protocol.c_str());

	string request = make_request(command, command_arguments);
	exec_command(command, request);
}

void SimpleUPnP::GetConnectionTypeInfo()
{
	string control_parameters = "<NewConnectionType></NewConnectionType>\r\n"       \
								"<NewPossibleConnectionTypes></NewPossibleConnectionTypes>";

	const string command = "GetConnectionTypeInfo";
	string command_arguments = format_string(control_parameters);

	string request = make_request(command, command_arguments);
	exec_command(command, request);
}

void SimpleUPnP::GetStatusInfo()
{
	string control_parameters = "<NewConnectionStatus></NewConnectionStatus>\r\n"       \
								"<NewLastConnectionError></NewLastConnectionError>\r\n" \
								"<NewUptime></NewUptime>";

	const string command = "GetStatusInfo";
	string command_arguments = format_string(control_parameters);

	string request = make_request(command, command_arguments);
	exec_command(command, request);
}

string SimpleUPnP::GetExternalIPAddress()
{
    try {
	    string control_parameters = "<NewExternalIPAddress></NewExternalIPAddress>";

	    const string command = "GetExternalIPAddress";
	    string command_arguments = format_string(control_parameters);

	    string request = make_request(command, command_arguments);
	    exec_command(command, request);
    }
    catch (exception &e) {
        cout << e.what() << endl;
    }
}

void SimpleUPnP::GetNatRSIPStatus()
{
	string control_parameters = "<NewRSIPAvailable></NewRSIPAvailable>\r\n"	\
								"<NewNATEnabled></NewNATEnabled>\r\n";

	const string command = "GetNATRSIPStatus";
	string command_arguments = format_string(control_parameters);

	string request = make_request(command, command_arguments);
	exec_command(command, request);
}

map<string, vector<string>> SimpleUPnP::InternalIP()
{
	struct ifaddrs * ifa=NULL;
	void * tmp_ip_addr;

	char ipv4_addr[INET_ADDRSTRLEN];
	char ipv6_addr[INET6_ADDRSTRLEN];
	map<string, vector<string>> addresses;

	getifaddrs(&ifa);

	while(ifa) {
		if (!ifa->ifa_addr)
			continue;

		if(strcmp(ifa->ifa_name, "lo") == 0) {
			ifa = ifa->ifa_next;
			continue;
		}

		if (ifa->ifa_addr->sa_family == AF_INET) { // check if it is IPv4
			tmp_ip_addr=&((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
			inet_ntop(AF_INET, tmp_ip_addr, ipv4_addr, INET_ADDRSTRLEN);
			addresses["IPV4"].push_back(ipv4_addr);

		} else if (ifa->ifa_addr->sa_family == AF_INET6) { // check if it is IPv6
			tmp_ip_addr=&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr;
			inet_ntop(AF_INET6, tmp_ip_addr, ipv6_addr, INET6_ADDRSTRLEN);
			addresses["IPV6"].push_back(ipv6_addr);
		}

		ifa = ifa->ifa_next;
	}

	if (ifa)
		freeifaddrs(ifa);

	return addresses;
}

void SimpleUPnP::send_broadcast()
{
    struct sockaddr_in broadcast_addr;
    broadcast_addr.sin_family = AF_INET;
    broadcast_addr.sin_addr.s_addr = inet_addr(BROADCAST_ADDRESS.c_str());
    broadcast_addr.sin_port = htons(BROADCAST_PORT);

    udp_broadcast_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    char opt_val = 1;
    setsockopt(udp_broadcast_socket, SOL_SOCKET, SO_BROADCAST, &opt_val, sizeof(char));
    fcntl(udp_broadcast_socket, F_SETFL, fcntl(udp_broadcast_socket, F_GETFL) | O_NONBLOCK);

    sendto(udp_broadcast_socket, SEARCH_REQUEST_STRING.c_str(), SEARCH_REQUEST_STRING.size(), 0, (struct sockaddr*)&broadcast_addr, sizeof(struct sockaddr_in));
}

void SimpleUPnP::prepare_tcp_socket()
{
    tcp_sock = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in upnp_address;
    upnp_address.sin_family = AF_INET;
    upnp_address.sin_addr.s_addr = inet_addr(igd_host.c_str());
    upnp_address.sin_port = htons(igd_port);
    int ret = connect(tcp_sock, (struct sockaddr*)&upnp_address, sizeof(struct sockaddr_in));
}

string SimpleUPnP::exec_command(const string &command, const string &request)
{
    prepare_tcp_socket();
    write(tcp_sock, request.c_str(), request.length());

    string response;
    int count = time_out;
    while(count--)
    {
        response = read_response(tcp_sock, command);
        if(!response.empty())
        	break;
    }

    close(tcp_sock);

    return response;
}

string  SimpleUPnP::make_soap_envelope(const string &command, const string &request)
{
	const std::string SOAP_ACTION = "<?xml version=\"1.0\"?>\r\n"                       \
									"<s:Envelope xmlns:s="                              \
									"\"http://schemas.xmlsoap.org/soap/envelope/\" "    \
									"s:encodingStyle="                                  \
									"\"http://schemas.xmlsoap.org/soap/encoding/\">\r\n"\
									"<s:Body>\r\n"                                      \
									"<u:%s xmlns:u=\"%s\">\r\n%s\r\n"                   \
									"</u:%s>\r\n"                                       \
									"</s:Body>\r\n"                                     \
									"</s:Envelope>\r\n\r\n";

	string serviceType = WANIPConnection->FirstChildElement("serviceType")->GetText();
	return format_string(SOAP_ACTION, command.c_str(), serviceType.c_str(), request.c_str(), command.c_str());
}

string SimpleUPnP::make_http_header(const string &command, int soap_envelope_size)
{
	const std::string HTTP_HEADER_ACTION = "POST %s HTTP/1.1\r\n"                                      \
										   "Host: %s:%u\r\n"                                           \
										   "User-Agent: Linux/3.14.4-1-ARCH, UPnP/1.0, MiniUPnPc/\r\n" \
										   "Content-Length: %d\r\n"                                    \
										   "Content-Type: text/xml\r\n"                                \
										   "SOAPAction: \"%s#%s\"\r\n"                                 \
										   "Connection: Close\r\n"                                     \
										   "Cache-Control: no-cache\r\n"                               \
										   "Pragma: no-cache\r\n\r\n";


	string serviceType = WANIPConnection->FirstChildElement("serviceType")->GetText();
	return format_string(HTTP_HEADER_ACTION, controlURL.c_str(), igd_host.c_str(), igd_port, soap_envelope_size, serviceType.c_str(), command.c_str());

}

string SimpleUPnP::make_request(const string &command, const string &command_arguments)
{
	string soap_envelope = make_soap_envelope(command, command_arguments);
	string http_header = make_http_header(command, soap_envelope.size());

	string request = http_header + soap_envelope;
    return request;
}

void SimpleUPnP::get_description()
{
    std::string request = "GET " + igd_path + " HTTP/1.1\r\nHost: " + igd_host + ":" + to_string(igd_port) + "\r\n\r\n";

    prepare_tcp_socket();
    write(tcp_sock, request.c_str(), request.length());

    read_response(tcp_sock, "Description");

    close(tcp_sock);
}

void SimpleUPnP::parse_description(const string &xml_doc)
{
	igd_xml.Parse(xml_doc.c_str());

	tinyxml2::XMLElement *root = igd_xml.RootElement();

	InternetGatewayDevice = root->FirstChildElement("device");

	WANDevice = InternetGatewayDevice->FirstChildElement("deviceList")->FirstChildElement();
	string wan_device = WANDevice->FirstChildElement("deviceType")->GetText();
	while(wan_device.find("WANDevice") == string::npos) {
		WANDevice = WANDevice->NextSiblingElement();

		if(!WANDevice)
			throw runtime_error("WANDevice not found");

		wan_device = WANDevice->FirstChildElement("deviceType")->GetText();
	}

	WANConnectionDevice = WANDevice->FirstChildElement("deviceList")->FirstChildElement();
	string wan_connection_device = WANConnectionDevice->FirstChildElement("deviceType")->GetText();
	while(wan_connection_device.find("WANConnectionDevice") == string::npos) {
		WANConnectionDevice = WANConnectionDevice->NextSiblingElement();

		if(!WANConnectionDevice)
			throw runtime_error("WANConnectionDevice not found");

		wan_connection_device = WANConnectionDevice->FirstChildElement("deviceType")->GetText();
	}

	WANIPConnection = WANConnectionDevice->FirstChildElement("serviceList")->FirstChildElement();
	string wan_ip_connection = WANIPConnection->FirstChildElement("serviceType")->GetText();
	while(wan_ip_connection.find("WANIPConnection") == string::npos) {
		WANIPConnection = WANIPConnection->NextSiblingElement();

		if(!WANIPConnection)
			throw runtime_error("WANIPConnection not found");

		wan_ip_connection = WANIPConnection->FirstChildElement("serviceType")->GetText();
	}

	cout << InternetGatewayDevice->FirstChildElement("deviceType")->GetText() << endl;
	cout << WANDevice->FirstChildElement("deviceType")->GetText() << endl;
	cout << WANConnectionDevice->FirstChildElement("deviceType")->GetText() << endl;
	cout << WANIPConnection->FirstChildElement("serviceType")->GetText() << endl;

	controlURL = WANIPConnection->FirstChildElement("controlURL")->GetText();
	cout << controlURL << endl;
}

void SimpleUPnP::RouterInfo()
{
	cout << "=======================+ ROUTER INFORMATION +=======================" << endl;

	cout << "Presentation URL: "
		 <<	InternetGatewayDevice->FirstChildElement("presentationURL")->GetText() << endl
		 << "Friendly Name: "
		 << InternetGatewayDevice->FirstChildElement("friendlyName")->GetText() << endl
		 << "Manufacturer: "
		 << InternetGatewayDevice->FirstChildElement("manufacturer")->GetText() << endl
		 << "Manufacturer URL: "
		 << InternetGatewayDevice->FirstChildElement("manufacturerURL")->GetText() << endl
		 << "Model Description: "
		 << InternetGatewayDevice->FirstChildElement("modelDescription")->GetText() << endl
		 << "Model Name: "
		 << InternetGatewayDevice->FirstChildElement("modelName")->GetText() << endl
		 << "Model Number: "
		 << InternetGatewayDevice->FirstChildElement("modelNumber")->GetText() << endl
		 << "Model URL: "
		 << InternetGatewayDevice->FirstChildElement("modelURL")->GetText() << endl
		 << "Serial Number: "
		 << InternetGatewayDevice->FirstChildElement("serialNumber")->GetText() << endl
		 << "UDN: "
		 << InternetGatewayDevice->FirstChildElement("UDN")->GetText() << endl
		 << "UPC: "
		 << InternetGatewayDevice->FirstChildElement("UPC")->GetText() << endl;

	cout << "=====================================================================" << endl;
}

string SimpleUPnP::read_response(int sock, const string &command)
{
    char buffer[BUFFER_SIZEz];
    string response {};
    while(read(sock, buffer, BUFFER_SIZEz) > 0) {
        response += buffer;
        memset(buffer, 0, BUFFER_SIZEz);
    }

    if (command == "Description")
    	parse_description(response);
    string ret = parse_response(response, command);

    if(ret.empty())
    	return "";

    return ret;
}

string SimpleUPnP::parse_response(const string response, const string &command)
{
	size_t end_http_header = response.find("<?xml");
	if (end_http_header != string::npos) {
		string http_header = response.substr(0, end_http_header);

		string xml_doc = response.substr(end_http_header);
    	XMLDocument xml_response;
    	xml_response.Parse(xml_doc.c_str());
    	XMLElement *Envelope = xml_response.FirstChildElement("SOAP-ENV:Envelope");

    	if(Envelope) {
	    	XMLElement *Body = Envelope->FirstChildElement("SOAP-ENV:Body");
	    	if (Body) {
	    		XMLElement *request_name = Body->FirstChildElement();
	    		if(request_name) {
	    			cout << request_name->Value() << endl;
	    			XMLElement *return_val = request_name->FirstChildElement();
	    			while (return_val) {
	    				cout << "\t-> " << return_val->Name() << ": " << return_val->GetText() << endl;
	    				return_val = return_val->NextSiblingElement();
	    			}
	    		}
	    	}
	    }
	}

    return response;
}
